//Generated by ChatGPT 
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define SIZE 8

// Define piece codes
enum Piece { EMPTY, PAWN_W, KNIGHT_W, BISHOP_W, ROOK_W, QUEEN_W, KING_W,
             PAWN_B, KNIGHT_B, BISHOP_B, ROOK_B, QUEEN_B, KING_B };

enum Player { WHITE, BLACK };

// Chessboard initialization
enum Piece board[SIZE][SIZE] = {
    {ROOK_B, KNIGHT_B, BISHOP_B, QUEEN_B, KING_B, BISHOP_B, KNIGHT_B, ROOK_B},
    {PAWN_B, PAWN_B, PAWN_B, PAWN_B, PAWN_B, PAWN_B, PAWN_B, PAWN_B},
    {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},
    {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},
    {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},
    {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},
    {PAWN_W, PAWN_W, PAWN_W, PAWN_W, PAWN_W, PAWN_W, PAWN_W, PAWN_W},
    {ROOK_W, KNIGHT_W, BISHOP_W, QUEEN_W, KING_W, BISHOP_W, KNIGHT_W, ROOK_W}
};

void printBoard() {
    const char *pieces = " PNBRQKpnbrqk";
    
    // Print the top border
    printf("  +-----------------+\n");

    for (int i = 0; i < SIZE; i++) {
        printf("%d | ", SIZE - i); // Print left side numbers with a border
        for (int j = 0; j < SIZE; j++) {
            printf("%c ", pieces[board[i][j]]);
        }
        printf("| %d\n", SIZE - i); // Right side numbers with a border
    }

    // Print the bottom border
    printf("  +-----------------+\n");
    printf("    A B C D E F G H\n"); // Column labels on the bottom
}

bool is_path_clear(int sx, int sy, int dx, int dy) {
    int x_dir = (dx - sx) ? (dx - sx) / abs(dx - sx) : 0;
    int y_dir = (dy - sy) ? (dy - sy) / abs(dy - sy) : 0;
    int x = sx + x_dir, y = sy + y_dir;

    while (x != dx || y != dy) {
        if (board[x][y] != EMPTY) return false;
        x += x_dir;
        y += y_dir;
    }
    return true;
}

bool is_valid_move(int sx, int sy, int dx, int dy, enum Player player) {
    // Basic bounds checking
    if (sx < 0 || sy < 0 || dx < 0 || dy < 0 || sx >= SIZE || sy >= SIZE || dx >= SIZE || dy >= SIZE)
        return false;

    enum Piece src = board[sx][sy];
    enum Piece dst = board[dx][dy];

    // Check if the destination has a piece from the same player
    if ((player == WHITE && dst <= KING_W && dst != EMPTY) ||
        (player == BLACK && dst >= PAWN_B))
        return false;

    int x_diff = abs(dx - sx);
    int y_diff = abs(dy - sy);

    // Movement rules for each piece
    switch (src) {
        case PAWN_W:
            if (dx == sx - 1 && sy == dy && dst == EMPTY) return true; // Forward move
            if (sx == 6 && dx == sx - 2 && sy == dy && dst == EMPTY && board[sx - 1][sy] == EMPTY) return true; // Double move
            if (dx == sx - 1 && (dy == sy - 1 || dy == sy + 1) && dst >= PAWN_B) return true; // Capture
            break;
        case PAWN_B:
            if (dx == sx + 1 && sy == dy && dst == EMPTY) return true; // Forward move
            if (sx == 1 && dx == sx + 2 && sy == dy && dst == EMPTY && board[sx + 1][sy] == EMPTY) return true; // Double move
            if (dx == sx + 1 && (dy == sy - 1 || dy == sy + 1) && dst <= KING_W) return true; // Capture
            break;
        case ROOK_W:
        case ROOK_B:
            if ((sx == dx || sy == dy) && is_path_clear(sx, sy, dx, dy)) return true;
            break;
        case KNIGHT_W:
        case KNIGHT_B:
            if ((x_diff == 2 && y_diff == 1) || (x_diff == 1 && y_diff == 2)) return true;
            break;
        case BISHOP_W:
        case BISHOP_B:
            if (x_diff == y_diff && is_path_clear(sx, sy, dx, dy)) return true;
            break;
        case QUEEN_W:
        case QUEEN_B:
            if ((x_diff == y_diff || sx == dx || sy == dy) && is_path_clear(sx, sy, dx, dy)) return true;
            break;
        case KING_W:
        case KING_B:
            if (x_diff <= 1 && y_diff <= 1) return true;
            break;
        default:
            return false;
    }
    return false;
}

bool is_in_check(enum Player player) {
    int king_x, king_y;

    // Find the king's position on the board
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            if ((player == WHITE && board[i][j] == KING_W) ||
                (player == BLACK && board[i][j] == KING_B)) {
                king_x = i;
                king_y = j;
                break;
            }
        }
    }

    // Check all squares for opponent pieces that can attack the king
    for (int x = 0; x < SIZE; x++) {
        for (int y = 0; y < SIZE; y++) {
            if ((player == WHITE && board[x][y] >= PAWN_B) ||
                (player == BLACK && board[x][y] <= KING_W && board[x][y] != EMPTY)) {
                if (is_valid_move(x, y, king_x, king_y, player == WHITE ? BLACK : WHITE)) {
                    return true; // King is in check
                }
            }
        }
    }
    return false; // King is not in check
}

void move_piece(int sx, int sy, int dx, int dy) {
    board[dx][dy] = board[sx][sy];
    board[sx][sy] = EMPTY;
}

int main() {
    enum Player player = WHITE;
    char start[3], dest[3];
    int sx, sy, dx, dy;

    while (1) {
        printBoard();
        
        // Check if the player is in check
        if (is_in_check(player)) {
            printf("Check!\n");
        }

        printf("%s's turn. Enter move (e.g., E2 E4): ", player == WHITE ? "White" : "Black");
        scanf("%2s %2s", start, dest);

        // Convert input to board coordinates
        sy = start[0] - 'A';
        sx = SIZE - (start[1] - '0');
        dy = dest[0] - 'A';
        dx = SIZE - (dest[1] - '0');

        // Make the move if valid
        if (is_valid_move(sx, sy, dx, dy, player)) {
            move_piece(sx, sy, dx, dy);
            player = (player == WHITE) ? BLACK : WHITE;
        } else {
            printf("Invalid move, please try again.\n");
        }
    }

    return 0;
}